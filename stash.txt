let important_node = root_node
	.children(&mut root_node.walk())
	.find(|n| n.kind() == "select_statement")  select_clause PANICS
	.unwrap()
	.children(&mut root_node.walk())
	.find(|n| n.kind() == "where_clause")
	.unwrap();

let important_range = important_node.byte_range();

let important_text = &source_code[important_range.start as
usize..important_range.end as usize];

println!("WHERE statement: {}", important_text);
println!(
	"Byte range: {} - {}",
	important_range.start, important_range.end
);
let mut cursor = parser.parse(source_code, None).unwrap().walk();
let lang = parser
	.parse(source_code, None)
	.unwrap()
	.root_node()
	.named_children(&mut cursor);
println!("{:?}", lang);



println!(
	"\nNode text: {}",
	node.utf8_text(source_code.as_bytes()).unwrap()
);
println!("Node kind: {}", node.kind());
println!(
	"Node range: {} - {}",
	node.byte_range().start,
	node.byte_range().end
);











fn print_leaf_nodes(node: &Node, source_code: &str) {
	if node.child_count() == 0 {
		println!("{}", &source_code[node.byte_range()])
	} else {
		for i in 0..node.child_count() {
			print_leaf_nodes(&node.child(i).unwrap(), source_code);
		}
	}
}

fn list_nodes(node: &Node, source_code: &str, mut level: u8) {
	level += 1;
	for child in node.children(&mut node.walk()) {
		// NOTE: LEVELS

		println!(
			"-[ {}. Node {} ]-)\n{}",
			level,
			child.kind(),
			child.utf8_text(source_code.as_bytes()).unwrap()
		);

		list_nodes(&child, source_code, level)
	}
}

fn find_clauses(node: &Node, source_code: &str, file: &mut File, suffix: &str) -> Result<()> {
	// NOTE: I should do shit here to add the semicolon
	// if node.kind().ends_with("statement") {}

	if node.kind().ends_with("clause") {
		let node_text = node.utf8_text(source_code.as_bytes()).unwrap();
		let stripped = node_text
			.split_whitespace()
			.collect::<Vec<&str>>()
			.join(" ");

		writeln!(file, "{}{}", &stripped, suffix)?;
	}

	for (index, child) in node.children(&mut node.walk()).enumerate() {
		if !(node.kind().ends_with("subexpression")) {
			// NOTE: for some reason node.walk().goto_next_sibling() was always returning
			// false
			let mut suffix = "";
			if index + 1 == node.children(&mut node.walk()).len() {
				suffix = ";";
			}

			find_clauses(&child, source_code, file, suffix)?;
		}
	}

	// if node.kind().ends_with("statement") {
	// 	writeln!(file, ";")?;
	// }

	Ok(())
}

// fn indent(node: &str, kind: &str) -> String {
// 	let whitespace: &str;
//
// 	match kind {
// 		"from_clause" => whitespace = "  ",
// 		"where_clause" => whitespace = " ",
// 		_ => whitespace = ""
// 	}
//
// 	format!("{}{}", whitespace, node)
// }

